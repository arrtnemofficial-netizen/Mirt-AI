---
name: Prod
overview: ""
todos: []
---

#План залізобетонного допилу (агресивно, але акуратно)

## Внутрішній аналіз

Поточний стан уже “працює”, але має 2 системні ризики: (1) SSOT-дрейф (правила/keywords/фолбеки розкидані по різних вузлах), (2) 4 “god files” у AI шарі (650–964 LOC) → конфлікти/регресії при будь-яких змінах. Для ManyChat Instagram при 50–200 concurrent sessions головний ворог — latency + таймаути + конкуренція за DB/LLM.

## Альтернативи (A/B/C) і вибір

- **A: Big-bang refactor** (переписати orchestration/rules одразу). Плюс: швидко “красиво”. Мінус: високий шанс зламати флоу і втратити стабільність.
- **B: Strangler-fig SSOT-first (рекомендовано)**: спочатку централізуємо правила/контракти (SSOT), потім розрізаємо великі файли маленькими PR, збереження поведінки гарантуємо тестами.
- **C: Freeze + лише performance patching**: швидко зменшує latency, але не лікує причину конфліктів/дрейфу.

Я обираю **B**, бо воно дає найкращий баланс: зберігаємо “як зараз працює”, але системно зменшуємо ризики і вартість підтримки.

## Цілі (що означає “краще”)

- **Надійність**: відсутність втрат state при рестартах; нуль “зависань” на checkpointer/LLM; контрольовані фолбеки.
- **Latency (ManyChat)**: ціль **p95 < 10s**, p99 < 18s для тексту; для vision — p95 < 35s (або одразу “інформативний проміжний bubble”).
- **Підтримуваність**: прибрати SSOT-дублювання; зменшити “god files” до < 400 LOC кожен (або чіткі підмодулі).
- **Доказовість**: зміни не приймаються без regression/golden-flow тестів.

## Контекст (факти з репозиторію)

- Найбільші AI-файли: 
- [src/agents/langgraph/nodes/vision.py](src/agents/langgraph/nodes/vision.py) ~964 LOC
- [src/agents/langgraph/nodes/payment.py](src/agents/langgraph/nodes/payment.py) ~673 LOC
- [src/agents/langgraph/checkpointer.py](src/agents/langgraph/checkpointer.py) ~651 LOC
- [src/agents/langgraph/nodes/agent.py](src/agents/langgraph/nodes/agent.py) ~648 LOC
- Приклад SSOT-дрейфу: payment-proof keywords у [src/agents/langgraph/state_prompts.py](src/agents/langgraph/state_prompts.py) та [src/agents/langgraph/nodes/payment.py](src/agents/langgraph/nodes/payment.py) різні.

## План виконання (6 задач)

### ЗАДАЧА 1: Зафіксувати production safety harness (метрики, SLO, release gating)

- **Чому саме так**: без метрик “краще” стає суб’єктивним; ManyChat має жорсткі тайм-бюджети.
- **Що робимо**:
- Додати/узгодити 3 ключові метрики: `end_to_end_latency_ms`, `checkpointer_latency_ms`, `llm_latency_ms` (вже частково є у [src/services/observability.py](src/services/observability.py)).
- Визначити SLO: p95/p99 + %error; зафіксувати в runbook.
- Release стратегія: канарейка (5–10% сесій) + швидкий rollback.
- **Ризик**: без staging/трафіку канарейка може бути “сліпою”.
- **Як перевірю**: в логах є trace_id + latency; дашборд/алерти на p95.

### ЗАДАЧА 2: Прибрати SSOT-дублювання правил (keywords, детектори) через один rules-модуль

- **Чому саме так**: це головна причина “в одному місці працює, в іншому ні”.
- **Що робимо**:
- Створити пакет `src/agents/langgraph/rules/` як SSOT:
    - `payment_proof.py`: `detect_payment_proof(user_text, has_image, has_url) -> bool`
    - `offer_transition.py`: `detect_delivery_request(text) -> bool`
    - `cart_intent.py`: `detect_add_to_cart(user_text) -> bool`
- Замінити дублікати в:
    - [src/agents/langgraph/state_prompts.py](src/agents/langgraph/state_prompts.py)
    - [src/agents/langgraph/nodes/payment.py](src/agents/langgraph/nodes/payment.py)
    - [src/agents/langgraph/nodes/offer.py](src/agents/langgraph/nodes/offer.py)
    - [src/agents/langgraph/nodes/agent.py](src/agents/langgraph/nodes/agent.py)
- Додати unit-тести на rules (edge cases: UA/RU, “скрин/скрін”, URL, image flag).
- **Ризик**: можна ненавмисно змінити поведінку детектора.
- **Як перевірю**: golden-flow/regression тести + порівняння логів “до/після” на однакових інпутах.

### ЗАДАЧА 3: Вирівняти політику prompt SSOT і прибрати приховані код-фолбеки

- **Чому саме так**: код-фолбеки створюють “секретні” гілки і різний UX між dev/prod.
- **Що робимо**:
- У проді зробити md-prompts SSOT (через `DISABLE_CODE_STATE_PROMPTS_FALLBACK=True`) у [src/conf/config.py](src/conf/config.py).
- Мінімізувати/винести `PAYMENT_TEMPLATES` з [src/agents/langgraph/nodes/payment.py](src/agents/langgraph/nodes/payment.py): або в prompt registry, або в явний “safe fallback policy” модуль.
- Залишити fallback тільки як **явний** режим “degraded”, який видно в логах.
- **Ризик**: якщо в проді не вистачає md-файлів — краш на старті.
- **Як перевірю**: smoke test на наявність prompts уже є; проганяємо його в CI + pre-deploy.

### ЗАДАЧА 4: Strangler-refactor “god files” у AI шарі без зміни зовнішніх інтерфейсів

- **Чому саме так**: це зменшує конфлікти і робить зміни локальними.
- **Що робимо (по файлах)**:
- [src/agents/langgraph/nodes/vision.py](src/agents/langgraph/nodes/vision.py) → винести в підмодулі `nodes/vision/`:
    - `escalation.py`, `enrichment.py`, `render.py`, залишити `vision_node()` як thin orchestrator.
- [src/agents/langgraph/nodes/payment.py](src/agents/langgraph/nodes/payment.py) → розділити “extraction/validation/render/HITL”.
- [src/agents/langgraph/nodes/agent.py](src/agents/langgraph/nodes/agent.py) → продовжити extraction (вже є helpers), винести cart-logic + phase transitions.
- [src/agents/langgraph/checkpointer.py](src/agents/langgraph/checkpointer.py) → відокремити: (a) env resolution, (b) pool config, (c) instrumentation.
- **Ризик**: циклічні імпорти, subtle behavior changes.
- **Як перевірю**: 1) імпортні smoke тести, 2) повний `pytest`, 3) smoke “graph builds” тест.

### ЗАДАЧА 5: Performance hardening під ManyChat Instagram 50–200 concurrent

- **Чому саме так**: зараз найбільший прод-ризик — latency/таймаути.
- **Що робимо**:
- Перерахунок pool sizes (checkpointer + redis/celery) на основі реального p95 і DB capacity:
    - `CHECKPOINTER_POOL_MAX_SIZE`: з 2 → 5-8 (для 50-200 concurrent, з урахуванням DB max_connections)
    - `CHECKPOINTER_POOL_MIN_SIZE`: залишити 0 (on-demand opening працює)
    - `CELERY_CONCURRENCY`: з 4 → 8-12 (якщо Celery використовується для ManyChat)
- Додати backpressure policy: якщо LLM повільний — віддати “interim bubble” (ManyChat split-send вже є) і дотягнути відповідь:
    - У [src/integrations/manychat/push_client.py](src/integrations/manychat/push_client.py) додати перевірку `MANYCHAT_FALLBACK_AFTER_SECONDS` перед LLM викликом
    - Якщо минуло > 8s без відповіді — відправити `MANYCHAT_INTERIM_TEXT` і продовжити обробку в фоні
- Оптимізувати найчастіші DB операції:
    - Catalog lookups: вже є кеш у [src/services/catalog_service.py](src/services/catalog_service.py), перевірити TTL (зараз 2-5 хв)
    - Checkpointer writes: зменшити `aput_writes` calls через batching (групувати metadata updates)
    - Vision enrichment: кешувати `_enrich_product_from_db` результати на рівні сесії (TTL 60s)
- **Ризик**: збільшення пулів може вбити Postgres (max_connections). Треба перевірити DB capacity перед зміною.
- **Як перевірю**: load test з 50-100 concurrent sessions, моніторинг DB connections + latency p95/p99.

### ЗАДАЧА 6: Фінальна валідація та регресійні тести перед продакшн

- **Чому саме так**: всі зміни мають бути покриті тестами; golden flows не мають регресувати.
- **Що робимо**:
- Прогнати повний `pytest` suite (зараз 1161 passed) після кожної задачі 1-5.
- Додати/оновити golden-flow тести для критичних сценаріїв:
    - `tests/test_golden_flows.py`: перевірити що payment flow не зламався після rules extraction
    - `tests/test_payment_phases_regression.py`: перевірити що phase transitions працюють з новими rules
    - `tests/test_vision_escalation_regression.py`: перевірити що dual-track escalation працює
- Smoke test на імпорти після refactoring (задача 4):
    - `tests/smoke/test_imports.py`: перевірити що всі нові модулі імпортуються без циклічних залежностей
    - `tests/smoke/test_graph_builds.py`: перевірити що граф будується без помилок
- Створити runbook з SLO та процедурами rollback:
    - Документ `docs/PRODUCTION_RUNBOOK.md` з SLO (p95/p99), alert thresholds, rollback командами
- **Ризик**: якщо тести не покривають edge cases — регресія може прослизнути.
- **Як перевірю**: всі тести green + ручна перевірка 2-3 критичних flows на staging (якщо є).