"""
CRM Order Mapper - order payload contract.
========================================
Maps escalation reasons and agent outputs to CRM actions.

Usage:
    from src.integrations.crm.order_mapper import OrderMapper, OrderPayload

    payload = OrderMapper.from_agent_response(response)

    action = OrderMapper.get_crm_action(escalation_reason)
"""

from __future__ import annotations

import logging
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field, field_validator

from src.core.prompt_registry import load_yaml_from_registry
from src.core.registry_keys import SystemKeys
from src.services.core.client_parser_config import get_client_parser_list


logger = logging.getLogger(__name__)


# =============================================================================
# CRM ACTIONS
# =============================================================================


class CRMAction(str, Enum):
    """Actions to perform in CRM."""

    CREATE_ORDER = "create_order"
    UPDATE_ORDER = "update_order"
    ASSIGN_MANAGER = "assign_manager"
    CREATE_COMPLAINT = "create_complaint"
    LOG_INTERACTION = "log_interaction"
    NO_ACTION = "no_action"


# =============================================================================
# ESCALATION â†’ CRM ACTION MAPPING
# =============================================================================

ESCALATION_REASON_TO_ACTION: dict[str, CRMAction] = {
    # Order flow
    "ORDER_CONFIRMED_ASSIGN_MANAGER": CRMAction.ASSIGN_MANAGER,
    "PAYMENT_CONFIRMED": CRMAction.UPDATE_ORDER,
    "ORDER_CREATED": CRMAction.CREATE_ORDER,
    # Complaints
    "COMPLAINT": CRMAction.CREATE_COMPLAINT,
    "NEGATIVE_FEEDBACK": CRMAction.CREATE_COMPLAINT,
    "DELIVERY_ISSUE": CRMAction.CREATE_COMPLAINT,
    # Admin/technical
    "ADMIN_NO_PRODUCT_DATA": CRMAction.LOG_INTERACTION,
    "MODERATION_BLOCK": CRMAction.LOG_INTERACTION,
    "OUT_OF_DOMAIN": CRMAction.NO_ACTION,
    # Default
    "UNKNOWN": CRMAction.LOG_INTERACTION,
}


def get_crm_action(escalation_reason: str) -> CRMAction:
    """Map escalation reason to CRM action."""
    reason_upper = (escalation_reason or "").upper().strip()

    # Try exact match
    if reason_upper in ESCALATION_REASON_TO_ACTION:
        return ESCALATION_REASON_TO_ACTION[reason_upper]

    # Try partial match
    for key, action in ESCALATION_REASON_TO_ACTION.items():
        if key in reason_upper or reason_upper in key:
            return action

    return CRMAction.LOG_INTERACTION


# =============================================================================
# ORDER PAYLOAD (Contract)
# =============================================================================


class OrderProduct(BaseModel):
    """Product in order."""

    id: int = Field(..., gt=0)
    name: str
    size: str = ""
    color: str = ""
    price: float = Field(..., gt=0)
    quantity: int = Field(default=1, ge=1)
    sku: str | None = None


class CustomerInfo(BaseModel):
    """Customer information for order."""

    full_name: str = Field(default="", description="Full name")
    phone: str = Field(default="", description="Phone")
    city: str = Field(default="", description="City")
    nova_poshta: str = Field(default="", description="Nova Poshta branch")
    payment_method: str = Field(default="", description="Payment method")

    @property
    def is_complete(self) -> bool:
        """Check if all required fields are filled."""
        return bool(self.full_name and self.phone and self.city and self.nova_poshta)


class OrderPayload(BaseModel):
    """
    Order payload contract.

    Fields that LLM CAN initiate:
    - products (from tool_result)
    - customer_info (from user messages)
    - notes

    Fields that LLM CANNOT initiate (system-managed):
    - order_id (generated by CRM)
    - session_id (from input)
    - created_at (system timestamp)
    - status (CRM workflow)
    """

    # LLM can provide
    products: list[OrderProduct] = Field(default_factory=list)
    customer_info: CustomerInfo = Field(default_factory=CustomerInfo)
    notes: str = Field(default="", description="Additional notes from conversation")
    total_amount: float = Field(default=0, ge=0)
    prepayment_amount: float = Field(default=0, ge=0)

    # System-managed (not from LLM)
    session_id: str = Field(default="", description="System: session ID")
    channel: str = Field(default="", description="System: source channel")

    @field_validator("total_amount", mode="before")
    @classmethod
    def calculate_total(cls, v, info):
        """Auto-calculate total if not provided."""
        if v and v > 0:
            return v
        # Try to calculate from products
        products = info.data.get("products", [])
        if products:
            return sum(p.price * p.quantity for p in products if isinstance(p, OrderProduct))
        return 0

    def to_snitkix_format(self) -> dict[str, Any]:
        """Convert to Snitkix CRM format."""
        return {
            "session_id": self.session_id,
            "channel": self.channel,
            "customer": {
                "name": self.customer_info.full_name,
                "phone": self.customer_info.phone,
                "city": self.customer_info.city,
                "delivery_address": self.customer_info.nova_poshta,
            },
            "products": [
                {
                    "product_id": p.id,
                    "name": p.name,
                    "size": p.size,
                    "color": p.color,
                    "price": p.price,
                    "quantity": p.quantity,
                    "sku": p.sku,
                }
                for p in self.products
            ],
            "total": self.total_amount,
            "prepayment": self.prepayment_amount,
            "payment_method": self.customer_info.payment_method,
            "notes": self.notes,
        }


# =============================================================================
# ORDER MAPPER
# =============================================================================


class OrderMapper:
    """Maps agent response to CRM order payload."""

    @classmethod
    def from_agent_response(
        cls,
        response: dict[str, Any],
        session_id: str = "",
        channel: str = "",
    ) -> OrderPayload | None:
        """
        Create OrderPayload from agent response.
        Returns None if not an order-related response.
        """
        # Check if this is a checkout/order event
        event = response.get("event", "")
        if event not in ("checkout", "escalation"):
            return None

        # Check escalation reason
        escalation = response.get("escalation", {})
        reason = escalation.get("reason", "")
        action = get_crm_action(reason)

        if action not in (CRMAction.CREATE_ORDER, CRMAction.ASSIGN_MANAGER, CRMAction.UPDATE_ORDER):
            return None

        # Extract products
        products = []
        for p in response.get("products", []):
            try:
                products.append(
                    OrderProduct(
                        id=p.get("id") or p.get("product_id"),
                        name=p.get("name", ""),
                        size=p.get("size", ""),
                        color=p.get("color", ""),
                        price=p.get("price", 0),
                        quantity=p.get("quantity", 1),
                        sku=p.get("sku"),
                    )
                )
            except Exception as e:
                logger.warning("Failed to parse product: %s", e)

        if not products:
            logger.warning("Order response has no valid products")
            return None

        # Calculate total
        total = sum(p.price * p.quantity for p in products)

        return OrderPayload(
            products=products,
            total_amount=total,
            session_id=session_id,
            channel=channel,
            notes=response.get("metadata", {}).get("notes", ""),
        )

    @classmethod
    def extract_customer_info(cls, messages: list[dict[str, Any]]) -> CustomerInfo:
        """
        Extract customer info from conversation messages.
        Looks for patterns: name, phone, city, NP.
        """
        import re

        info = CustomerInfo()
        all_text = " ".join(m.get("content", "") for m in messages if m.get("role") == "user")
        all_text_lower = all_text.lower()

        # Phone pattern
        phone_match = re.search(r"(\+?380\d{9}|\d{10})", all_text)
        if phone_match:
            info.phone = phone_match.group(1)

        # Nova Poshta patterns from registry
        np_patterns = get_client_parser_list("np_patterns")
        for p in np_patterns:
            try:
                compiled = re.compile(p, re.IGNORECASE)
                np_match = compiled.search(all_text_lower)
                if np_match:
                    data = load_yaml_from_registry(SystemKeys.TEXTS.value)
                    prefix = (
                        data.get("ui", {}).get("np_branch_prefix", "Branch #")
                        if isinstance(data, dict)
                        else "Branch #"
                    )
                    info.nova_poshta = f"{prefix}{np_match.group(1)}"
                    break
            except re.error:
                # Skip invalid patterns
                continue

        # City matching (from registry)
        cities = get_client_parser_list("cities")
        for city in cities:
            if city and city in all_text_lower:
                info.city = city.capitalize()
                break

        return info
